---
title: 新一轮Java面试题
author: 墨白
top: false
cover: false
toc: true
mathjax: false
tags:
  - 面试题
categories:
  - Java
abbrlink: 3832923852
date: 2020-03-31 17:14:44
img:
coverImg:
password:
summary:
---

# 新一轮Java面试题

[Java中23种设计模式](  https://www.cnblogs.com/pony1223/p/7608955.html )参考文章

![设计模式]( https://wang_lianjie.gitee.io/mobai_images.gitee.io/img/2020-03-27/5.jpg )

### 创建型模式

单例模式：某个类只能有一个实例，提供一个全局的访问点。

简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。

工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。

抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。

建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。

原型模式：通过复制现有的实例来创建新的实例。

### 结构性模式

适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。

组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。

装饰模式：动态的给对象添加新的功能。

代理模式：为其他对象提供一个代理以便控制这个对象的访问。

亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。

外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。

桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。



### 行为型模式

模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。

解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。

策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。

状态模式：允许一个对象在其对象内部状态改变时改变它的行为。

观察者模式：对象间的一对多的依赖关系。

备忘录模式：在不破坏封装的前提下，保持对象的内部状态。

中介者模式：用一个中介对象来封装一系列的对象交互。

命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。

访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。

责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。

迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。



### 逻辑题

####  1丶第一题

甲,乙,丙,丁四位同学中有一位同学为海啸灾区捐款1000元,当老师询问时,他们分别这样回答

* 甲:这1000元不是我捐的
* 乙:这1000元是丁捐的
* 丙:这1000元是乙捐的
* 丁:这1000元不是我捐的

这四个人只有一个说了真话,由此可见这1000元是谁捐的(___)

A:甲		B:乙		C:丙		D:丁

解题思路:四个人说的话乙和丁是矛盾的,真话在这两个人之间,那么甲和丙是假话,所以是甲捐的,选择A正确



#### 2丶第二题

 甲、乙、丙三人是同一家公司的员工，他们的未婚妻A、B、C也都是这家公司的职员。知情者介绍说：“A的未婚夫是乙的好友，并在三个男子中最年轻;丙的年龄比C的未婚夫大。”依据该知情者提供的情况，我们可以推出三对组合分别是( )。

* A.甲-A，乙-B，丙-C 

* B.甲-B，乙-A，丙-C 

* C.甲-C，乙-B，丙-A 

* D.甲-A，乙-C，丙-B

 解题思路:由已知条件可知，乙非A的未婚夫且A的未婚夫年龄最小，且丙比C未婚夫大，由此就可知，C的未婚夫是乙，A的未婚夫非乙非丙是甲，则丙是B的未婚夫，故选B。 



### 编程题:

#### 1.二叉树有哪三种遍历方法?

答: 

* 前根序遍历：先遍历根结点，然后遍历左子树，最后遍历右子树。

ABDHECFG

* 中根序遍历：先遍历左子树，然后遍历根结点，最后遍历右子树。

HDBEAFCG

* 后根序遍历：先遍历左子树，然后遍历右子树，最后遍历根节点。

HDEBFGCA



#### 2.面向对象的基本特征是?

答: 封装,继承,多态,抽象

1、抽象

忽略一个主题中与当前目标无关的东西，专注的注意与当前目标有关的方面。(就是把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口)。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一个数据抽象，而是过程抽象。

数据抽象 -->表示世界中一类事物的特征，就是对象的属性。比如鸟有翅膀，羽毛等(类的属性)

过程抽象 -->表示世界中一类事物的行为，就是对象的行为。比如鸟会飞，会叫(类的方法)

2、封装

封装是面向对象的特征之一，是对象和类概念的主要特性。封装就是把过程和数据包围起来，对数据的访问只能通过已定义的界面。如私有变量，用set，get方法获取。

封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。

3、继承

一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。

4、多态

多态是指允许不同类的对象对同一消息做出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活/抽象/行为共享/代码共享的优势，很好的解决了应用程序函数同名问题。总的来说，方法的重写，重载与动态链接构成多态性。java引入多态的概念原因之一就是弥补类的单继承带来的功能不足。

动态链接 -->对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将调用子类中的这个方法，这就是动态链接。

#### 3.模块设计的基本原则是?

答:

* 单一职责原则 ( SRP )

英文全称是Single Responsibility Principle，定义是一个类，应该只有一个引起它变化的原因。类变化的原因就是职责，如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。

* 开闭原则 ( OCP )

英文全称是Open Close Principle，定义是软件实体（包括类、模块、函数等）应该对于扩展时开放的，对于修改是封闭的。开闭原则是是面向对象设计中最重要的原则之一，其它很多的设计原则都是实现开闭原则的一种手段。

* 接口隔离原则 ( ISP )

英文全称是Interface Segregation Principle，这个原则的意思是使用多个隔离的接口，比使用单个接口要好。目的就是降低类之间的耦合度，便于软件升级和维护。

* 合成/聚合复用（CARP）

英文全称是Composite Reuse Principle，合成/聚合复用原则经常又叫做合成复用原则。合成/聚合复用原则的潜台词是：我只是用你的方法，我们不一定是同类。继承的耦合性更大，比如一个父类后来添加实现一个接口或者去掉一个接口，那子类可能会遭到毁灭性的编译错误，但如果只是组合聚合，只是引用类的方法，就不会有这种巨大的风险，同时也实现了复用

#### 4:事务包含是个特征,即A,C,I,D,它们分别指?

答:A: 原子性(Atomicity) 			B: 一致性(Consistency) 			C: 隔离性(Isolation) 			D: 持久性(Durability) 

### Java基础题

#### 1.Java中`GC`是指

答: Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，在使用JAVA的时候，一般不需要专门编写内存回收和垃圾清理代 码。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。

电脑的内存大小的不变的，当我们使用对象的时候，如使用New关键字的时候，就会在内存中生产一个对象，但是我们在使用JAVA开发的时候，当一个对象使用完毕之后我们并没有手动的释放那个对象所占用的内存，就这样在使用程序的过程中，对象越来越多，当内存存放不了这么多对象的时候，电脑就会崩溃了，JAVA为了解决这个问题就推出了这个自动清除无用对象的功能，或者叫机制，这就是GC，有个好听是名字叫垃圾回收，其实就在用来帮你擦屁股的，好让你安心写代码，不用管内存释放，对象清理的事情了。 

#### 2.线程实现的两种方式是?

答:	

* A: 继承Thread类 		
* B:实现Runnable接口

#### 3.Which are not Java keywords?(那些不是Java中的关键字)

A:true		B:sizeof		C:const		D:super		E:void

答:A,B

![Java关键字](https://wang_lianjie.gitee.io/mobai_images.gitee.io/img/2020-03-27/6.jpg )

#### 4.Which are not Java primitive types?(那些不是Java的基本数据类型?)

A:short	 		B:unit			C:unit					D:float	

* 整型：byte, short, int, long
* 字符型：char
* 浮点型：float, double
* 布尔型：boolean

#### 5.二叉树

若一棵二叉树的后序遍历序列为`KGFEMLIHONJDCBA`，中序遍历序列为`KEFGBLMHICNOJDA`，则其前序遍历序列()

* A.ABEKFGCHLMIDJNO
* B.ABEKFGMCHLIDJNO
* C.ABEKLFGCHLMIDJNO
* D.ABEMKFGCHLIDJNO



#### 6.判断下列声明是否正确,如果正确打(√),错误请标记（x）

* 1.接口是可以继承接口（√）
* 2.接口可以实现接口(x)
* 3.接口可以声明为私有的（x）
* 4.是否可以继承String类（x)
* 5.抽象类可以实现接口(√)
* 6.抽象类可以继承实体类（√）



### 问答题

#### 1.请说出数据库连接池工作机制是什么?

答: 连接池基本的思想是在`系统初始化`的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 

#### 2.forward和redirect的区别:

答:

 `从效率来说`
		forward:高.
		redirect:低. 

 一句话，转发是服务器行为，重定向是客户端行为。为什么这样说呢，这就要看两个动作的工作流程:[传送门]( https://www.cnblogs.com/fifiyong/p/5949689.html )



### SQL题

~~~sql
table1:
	custom-name		varchar	客户名
	rank			int		客户等级
	
table2:
	order-id	int		订单号
	custom-name varchar	 客户名
	order-date	date	订单时间
	accounts	int 	订单金额
~~~

* 查询2007年4月份所有等级大于3客户的订单总额

答:

* 查询每个等级客户的订单金额总数

答:

* 查询2007年4月份订单金额最大的前五名

答:



### 附加题

1.如上所述:JavaEE平台下,后端数据库频繁交互,如果后端数据库耦合性差,总是迟迟不能响应,应用可维护性,性能必将大受影响.其中,解决这个问题的一种方式是数据库优化,请简述JavaEE架构下数据库优化的方法.

答:

* 优化查询语句
* 使用索引
* 使用外键
* 锁定表
* 事务
*  使用联合(union)来代替手动创建的临时表
* 使用连接（JOIN）来代替子查询(Sub-Queries)
* 选取最适用的字段属性（创建字段）



2.为了提高系统的速度,数据库的设计也不容忽视.根据你掌握的知识和实际经验,你认为建立良好的数据库结构需要怎么做?

* 需求分析好后，找实体，不要有所落下
* 分析实体里所要涉及到的属性（比如学生，在这个数据库里我需要他的学号，但不需要他的籍贯）
* 分析属性的类型，长度。要想的长远点，比如学生名字的长度，汉族一般几位就够了，可万一来个维族，那几位长度就不够用了。
* 实体间的关系，要满足需求和现实
* 写出关系模式
* 优化关系模式（越满足后面的范式越好）
* 建数据库。属性，约束等最好字母+单词（正确的），这样易懂。
* 数据库安全性设置


### 内存溢出

#### 说几种常见的内存溢出和解决方案

```java
引起内存溢出的原因有很多种，常见的有以下几种：
　　1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
　　2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
　　3.代码中存在死循环或循环产生过多重复的对象实体；
　　4.使用的第三方软件中的BUG；
　　5.启动参数内存值设定的过小；
```

[解决方案参考本文]( https://www.cnblogs.com/leasonWang/p/11146030.html )

### 实现一个简单的冒泡排序

~~~java
public static void bubbleSort(int []arr) {
        for(int i =1;i<arr.length;i++) { 
            for(int j=0;j<arr.length-i;j++) {
                if(arr[j]>arr[j+1]) {
                    int temp = arr[j];
                     
                    arr[j]=arr[j+1];
                 
                    arr[j+1]=temp;
            }
            }    
        }
    }
~~~

